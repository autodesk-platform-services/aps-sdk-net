/* 
 * APS SDK
 *
 * The APS Platform contains an expanding collection of web service components that can be used with Autodesk cloud-based products or your own technologies. Take advantage of Autodesk’s expertise in design and engineering.
 *
 * Model Derivative
 *
 * Model Derivative Service Documentation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
using Autodesk.Forge.Core;
using Microsoft.Extensions.Options;
using System.Collections.Generic;
using System;
using System.Linq;
using System.Net.Http;
using System.Runtime.Serialization;
using Autodesk.ModelDerivative.Model;
using Autodesk.ModelDerivative.Client;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Autodesk.SDKManager;

namespace Autodesk.ModelDerivative.Http
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMetadataApi
    {
        /// <summary>
        /// List Model Views
        /// </summary>
        /// <remarks>
        /// Returns a list of model views (Viewables) in the source design specified by the &#x60;urn&#x60; URI parameter. It also returns the ID that uniquely identifies the model view. You can use this ID with other metadata endpoints to obtain information about the objects within model view.  
        /// 
        /// Most design applications like Fusion 360 and Inventor contain only one model view per design. However, some applications like Revit allow multiple model views (e.g., HVAC, architecture, perspective) per design.
        ///
        ///  **Note:** You can retrieve metadata only from an input file that has been translated to SVF or SVF2.
        /// </remarks>
        /// <exception cref="HttpRequestException">Thrown when fails to make API call</exception>
        /// <param name="urn">The Base64 (URL Safe) encoded design URN</param>/// <param name="acceptEncoding">A comma separated list of the algorthms you want the response to be encoded in, specified in the order of preference.    If you specify &#x60;&#x60;gzip&#x60;&#x60; or &#x60;&#x60;*&#x60;&#x60;, the service uses the GZIP algorithm to encode the response.  (optional)</param>/// <param name="urn2">The Base64 (URL Safe) encoded design URN (optional)</param>
        /// <returns>Task of ApiResponse&#60;ModelViews&#62;</returns>
        
        System.Threading.Tasks.Task<ApiResponse<ModelViews>> GetModelViewsAsync (string urn,  Region region = default,string acceptEncoding= default(string), string accessToken = null, bool throwOnError = true);
        /// <summary>
        /// Fetch Object tree
        /// </summary>
        /// <remarks>
        /// Returns a hierarchical list of objects (object tree) in the model view specified by the modelGuid URI parameter.  Before you call this endpoint you must call GET {urn}/metadata to obtain the ID (modelGuid) of the model view you want to get the object tree of.  Most design applications like Fusion 360 and Inventor contain only one model view per design. However, some applications like Revit allow multiple model views (e.g., HVAC, architecture, perspective) per design.  Note You can retrieve metadata only from a design that has been translated to SVF or SVF2. 
        /// </remarks>
        /// <exception cref="HttpRequestException">Thrown when fails to make API call</exception>
        /// <param name="urn">The Base64 (URL Safe) encoded design URN</param>/// <param name="modelGuid">Unique model view ID. Call GET {urn}/metadata to get the ID</param>/// <param name="acceptEncoding">A comma separated list of the algorthms you want the response to be encoded in, specified in the order of preference.    If you specify &#x60;&#x60;gzip&#x60;&#x60; or &#x60;&#x60;*&#x60;&#x60;, the service uses the GZIP algorithm to encode the response.  (optional)</param>/// <param name="xAdsForce">true: force retrieve the object tree even though it failed to be retrieved or got timeout (got 404 with error message) previously. false (default): retrieve the object tree, and previously failures are not replaced. (optional)</param>/// <param name="xAdsDerivativeFormat">Specifies what Object IDs to return, if the design has legacy SVF derivatives generated by the BIM Docs service. Possible values are:  - latest - (Default) Return SVF2 Object IDs. - fallback - Return SVF Object IDs.  Note  1. This parameter applies only to designs with legacy SVF derivatives generated by the BIM 360 Docs service. 2. The BIM 360 Docs service now generates SVF2 derivatives. SVF2 Object IDs may not be compatible with the SVF Object IDs previously generated by the BIM 360 Docs service. Setting this header to fallback may resolve backward compatibility issues resulting from Object IDs of legacy SVF derivatives being retained on the client side. 3. If you use this header with one derivative (URN), you must use it consistently across the following endpoints, whenever you reference the same derivative. - POST job (for OBJ output) - GET {urn}/metadata/{modelGuid} - GET {urn}/metadata/{modelGuid}/properties (optional)</param>/// <param name="forceget">true: Forcibly gets large resources even if they exceed the expected maximum size (20 MB). If the resource is larger than 800 MB, the server behaves as though forceget is false. In such a case, use the objectid query string parameter to download resources by Object ID one object at a time. Alternatively, you can use POST {urn}/metadata/{modelGuid}/properties:query to fetch only the properties you are interested in. false: (Default) Does not get resources if they exceed the expected maximum size (20 MB). (optional)</param>/// <param name="objectid">If specified, retrieves the sub-tree that has the specified object ID as its parent node. If this parameter is not specified, retrieves the entire object tree. (optional)</param>/// <param name="level">Specifies how many child levels of the hierarchy to return, when the objectid query string parameter is specified. Currently supports only level &#x3D; 1. (optional)</param>
        /// <returns>Task of ApiResponse&#60;ObjectTree&#62;</returns>
        
        System.Threading.Tasks.Task<ApiResponse<ObjectTree>> GetObjectTreeAsync (string urn, string modelGuid,  Region region = default,string acceptEncoding= default(string), bool? xAdsForce= default(bool?), XAdsDerivativeFormat? xAdsDerivativeFormat= default(XAdsDerivativeFormat), string forceget= default(string), int? objectid= default(int?), string level= default(string),  string accessToken = null, bool throwOnError = true);
        /// <summary>
        /// Fetch All Properties
        /// </summary>
        /// <remarks>
        /// Returns a list of properties of objects contained in the model view specified by the modelGuid URI parameter. This request returns all properties for all objects by default. However, you can use the objectid query string parameter to return all properties of a specified object.  Properties are returned as a flat list ordered, by their objectid. The objectid is a non-persistent ID assigned to an object when a design file is translated to the SVF or SVF2 format. This means that:  A design file must be translated to SVF or SVF2 before you can retrieve properties. The objectid of an object can change if the design is translated to SVF or SVF2 again. If you require a persistent ID to reference an object, use &#x60;externalId&#x60;.  **Note**: Before you call this endpoint:  Use the &#x60;GET {urn}/metadata&#x60; endpoint. Obtain the ID of the model view (Viewable) you want to check. Use the ID you obtained as the &#x60;modelGuid&#x60; URI parameter.  **Note**: &#x60;POST {urn}/metadata/{modelGuid}/properties:query&#x60; provides greater flexibility to retrieve only the properties you are interested in. What’s more the response is paginated. So, when the number of properties returned is large, it can getz you the results faster.
        /// </remarks>
        /// <exception cref="HttpRequestException">Thrown when fails to make API call</exception>
        /// <param name="urn">The Base64 (URL Safe) encoded design URN</param>/// <param name="modelGuid">Unique model view ID. Call GET {urn}/metadata to get the ID</param>/// <param name="acceptEncoding">A comma separated list of the algorthms you want the response to be encoded in, specified in the order of preference.    If you specify &#x60;&#x60;gzip&#x60;&#x60; or &#x60;&#x60;*&#x60;&#x60;, the service uses the GZIP algorithm to encode the response.  (optional)</param>/// <param name="xAdsForce">true: force retrieve the object tree even though it failed to be retrieved or got timeout (got 404 with error message) previously. false (default): retrieve the object tree, and previously failures are not replaced. (optional)</param>/// <param name="xAdsDerivativeFormat">Specifies what Object IDs to return, if the design has legacy SVF derivatives generated by the BIM Docs service. Possible values are:  - latest - (Default) Return SVF2 Object IDs. - fallback - Return SVF Object IDs.  Note  1. This parameter applies only to designs with legacy SVF derivatives generated by the BIM 360 Docs service. 2. The BIM 360 Docs service now generates SVF2 derivatives. SVF2 Object IDs may not be compatible with the SVF Object IDs previously generated by the BIM 360 Docs service. Setting this header to fallback may resolve backward compatibility issues resulting from Object IDs of legacy SVF derivatives being retained on the client side. 3. If you use this header with one derivative (URN), you must use it consistently across the following endpoints, whenever you reference the same derivative. - POST job (for OBJ output) - GET {urn}/metadata/{modelGuid} - GET {urn}/metadata/{modelGuid}/properties (optional)</param>/// <param name="objectid">he Object ID of the object you want to query properties for.  If objectid is omitted, the server returns properties for all objects. (optional)</param>/// <param name="forceget">true: Forcibly gets large resources even if they exceed the expected maximum size (20 MB). If the resource is larger than 800 MB, the server behaves as though forceget is false. In such a case, use the objectid query string parameter to download resources by Object ID one object at a time. Alternatively, you can use POST {urn}/metadata/{modelGuid}/properties:query to fetch only the properties you are interested in. false: (Default) Does not get resources if they exceed the expected maximum size (20 MB). (optional)</param>
        /// <returns>Task of ApiResponse&#60;AllProperties&#62;</returns>
        
        System.Threading.Tasks.Task<ApiResponse<AllProperties>> GetAllPropertiesAsync (string urn, string modelGuid, Region region = default, string acceptEncoding= default(string), bool? xAdsForce= default(bool?), XAdsDerivativeFormat? xAdsDerivativeFormat= default(XAdsDerivativeFormat), int? objectid= default(int?), string forceget= default(string),  string accessToken = null, bool throwOnError = true);
        /// <summary>
        /// Fetch Specific Properties
        /// </summary>
        /// <remarks>
        /// Queries the objects in the model view (Viewable) specified by the modelGuid URI parameter and returns the specified properties in a paginated list. You can limit the number of objects to be queried by specifying a filter in the request body.  Before you call this endpoint use the &#x60;GET {urn}/metadata endpoint&#x60;, to obtain the IDs of the model views (Viewables) contained in the design. After that, specify the ID of the model view you want to query as the &#x60;modelGuid&#x60; URI parameter.  **Note**: Before you query a model view for properties, the design must be translated to SVF or SVF2.
        /// </remarks>
        /// <exception cref="HttpRequestException">Thrown when fails to make API call</exception>
        /// <param name="urn">The Base64 (URL Safe) encoded design URN</param>/// <param name="modelGuid">Unique model view ID. Call GET {urn}/metadata to get the ID</param>/// <param name="acceptEncoding">A comma separated list of the algorthms you want the response to be encoded in, specified in the order of preference.    If you specify &#x60;&#x60;gzip&#x60;&#x60; or &#x60;&#x60;*&#x60;&#x60;, the service uses the GZIP algorithm to encode the response.  (optional)</param>/// <param name="specificPropertiesPayload"> (optional)</param>
        /// <returns>Task of ApiResponse&#60;SpecificProperties&#62;</returns>
        
        System.Threading.Tasks.Task<ApiResponse<SpecificProperties>> FetchSpecificPropertiesAsync (string urn, string modelGuid, Region region = default, string acceptEncoding= default(string), SpecificPropertiesPayload specificPropertiesPayload= default(SpecificPropertiesPayload),  string accessToken = null, bool throwOnError = true);
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class MetadataApi : IMetadataApi
    {
        ILogger logger;

        /// <summary>
        /// Initializes a new instance of the <see cref="MetadataApi"/> class
        /// using SDKManager object
        /// </summary>
        /// <param name="sdkManager">An instance of SDKManager</param>
        /// <returns></returns>
        public MetadataApi(SDKManager.SDKManager sdkManager)
        {
            this.Service = sdkManager.ApsClient.Service;
            this.logger = sdkManager.Logger;
        }
        private void SetQueryParameter(string name, object value, Dictionary<string, object> dictionary)
        {
            if(value is Enum)
            {
                var type = value.GetType();
                var memberInfos = type.GetMember(value.ToString());
                var enumValueMemberInfo = memberInfos.FirstOrDefault(m => m.DeclaringType == type);
                var valueAttributes = enumValueMemberInfo.GetCustomAttributes(typeof(EnumMemberAttribute), false);
                if(valueAttributes.Length > 0)
                {
                    dictionary.Add(name, ((EnumMemberAttribute)valueAttributes[0]).Value);
                }
            }
            else if(value is int)
            {
                if((int)value > 0)
                {
                    dictionary.Add(name, value);
                }
            }
            else
            {
                if(value != null)
                {
                    dictionary.Add(name, value);
                }
            }
        }
        private void SetHeader(string baseName, object value, HttpRequestMessage req)
        {
                if(value is DateTime)
                {
                    if((DateTime)value != DateTime.MinValue)
                    {
                        req.Headers.TryAddWithoutValidation(baseName, LocalMarshalling.ParameterToString(value)); // header parameter
                    }
                }
                else
                {
                    if (value != null)
                    {
                        if(!string.Equals(baseName, "Content-Range"))
                        {
                            req.Headers.TryAddWithoutValidation(baseName, LocalMarshalling.ParameterToString(value)); // header parameter
                        }
                        else
                        {
                            req.Content.Headers.Add(baseName, LocalMarshalling.ParameterToString(value));
                        }
                    }
                }

        }

        /// <summary>
        /// Gets or sets the ApsConfiguration object
        /// </summary>
        /// <value>An instance of the ForgeService</value>
        public ForgeService Service {get; set;}

        /// <summary>
        /// List Model Views
        /// </summary>
        /// <remarks>
        /// Returns a list of model views (Viewables) in the source design specified by the &#x60;urn&#x60; URI parameter. It also returns the ID that uniquely identifies the model view. You can use this ID with other metadata endpoints to obtain information about the objects within model view.  Most design applications like Fusion 360 and Inventor contain only one model view per design. However, some applications like Revit allow multiple model views (e.g., HVAC, architecture, perspective) per design.  **Note:** You can retrieve metadata only from an input file that has been translated to SVF or SVF2.
        /// </remarks>
        /// <exception cref="HttpRequestException">Thrown when fails to make API call</exception>
        /// <param name="urn">The Base64 (URL Safe) encoded design URN</param>/// <param name="acceptEncoding">A comma separated list of the algorthms you want the response to be encoded in, specified in the order of preference.    If you specify &#x60;&#x60;gzip&#x60;&#x60; or &#x60;&#x60;*&#x60;&#x60;, the service uses the GZIP algorithm to encode the response.  (optional)</param>/// <param name="urn2">The Base64 (URL Safe) encoded design URN (optional)</param>
        /// <returns>Task of ApiResponse&#60;ModelViews&#62;</returns>
        
        public async System.Threading.Tasks.Task<ApiResponse<ModelViews>> GetModelViewsAsync (string urn, Region region = default,string acceptEncoding= default(string), string accessToken = null, bool throwOnError = true)
        {
            logger.LogInformation("Entered into GetModelViewsAsync ");
             string regionPath = Utils.GetPathfromRegion(region);
            using (var request = new HttpRequestMessage())
            {
                var queryParam = new Dictionary<string, object>();
              
                request.RequestUri =
                    Marshalling.BuildRequestUri(regionPath + "{urn}/metadata",
                        routeParameters: new Dictionary<string, object> {
                            { "urn", urn},
                        },
                        queryParameters: queryParam
                    );

                request.Headers.TryAddWithoutValidation("Accept", "application/json");
                request.Headers.TryAddWithoutValidation("User-Agent", "APS SDK/MODEL DERIVATIVE/C#/1.0.0");
                if(!string.IsNullOrEmpty(accessToken))
                {
                    request.Headers.TryAddWithoutValidation("Authorization", $"Bearer {accessToken}");
                }



                SetHeader("Accept-Encoding", acceptEncoding, request);

                // tell the underlying pipeline what scope we'd like to use
                // if (scopes == null)
                // {
                    // TBD:Naren FORCE-4027 - If accessToken is null, acquire auth token using auth SDK, with defined scope.
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), "data:read ");
                // }
                // else
                // {
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), scopes);
                // }
                // if (scopes == null)
                // {
                    // TBD:Naren FORCE-4027 - If accessToken is null, acquire auth token using auth SDK, with defined scope.
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), "data:read ");
                // }
                // else
                // {
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), scopes);
                // }
                // if (scopes == null)
                // {
                    // TBD:Naren FORCE-4027 - If accessToken is null, acquire auth token using auth SDK, with defined scope.
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), "data:read ");
                // }
                // else
                // {
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), scopes);
                // }

                request.Method = new HttpMethod("GET");

                // make the HTTP request
                var response = await this.Service.Client.SendAsync(request);

                if (throwOnError)
                {
                    try
                    {
                      await response.EnsureSuccessStatusCodeAsync();
                    } catch (HttpRequestException ex) {
                      throw new ModelDerivativeApiException(ex.Message, response, ex);
                    }
                }
                else if (!response.IsSuccessStatusCode)
                {
                    logger.LogError($"response unsuccess with status code: {response.StatusCode}");
                    return new ApiResponse<ModelViews>(response, default(ModelViews));
                }
                logger.LogInformation($"Exited from GetModelViewsAsync with response statusCode: {response.StatusCode}");
                return new ApiResponse<ModelViews>(response, await LocalMarshalling.DeserializeAsync<ModelViews>(response.Content));

            } // using
        }
        /// <summary>
        /// Fetch Object tree
        /// </summary>
        /// <remarks>
        /// Returns a hierarchical list of objects (object tree) in the model view specified by the modelGuid URI parameter.  Before you call this endpoint you must call GET {urn}/metadata to obtain the ID (modelGuid) of the model view you want to get the object tree of.  Most design applications like Fusion 360 and Inventor contain only one model view per design. However, some applications like Revit allow multiple model views (e.g., HVAC, architecture, perspective) per design.  Note You can retrieve metadata only from a design that has been translated to SVF or SVF2. 
        /// </remarks>
        /// <exception cref="HttpRequestException">Thrown when fails to make API call</exception>
        /// <param name="urn">The Base64 (URL Safe) encoded design URN</param>/// <param name="modelGuid">Unique model view ID. Call GET {urn}/metadata to get the ID</param>/// <param name="acceptEncoding">A comma separated list of the algorthms you want the response to be encoded in, specified in the order of preference.    If you specify &#x60;&#x60;gzip&#x60;&#x60; or &#x60;&#x60;*&#x60;&#x60;, the service uses the GZIP algorithm to encode the response.  (optional)</param>/// <param name="xAdsForce">true: force retrieve the object tree even though it failed to be retrieved or got timeout (got 404 with error message) previously. false (default): retrieve the object tree, and previously failures are not replaced. (optional)</param>/// <param name="xAdsDerivativeFormat">Specifies what Object IDs to return, if the design has legacy SVF derivatives generated by the BIM Docs service. Possible values are:  - latest - (Default) Return SVF2 Object IDs. - fallback - Return SVF Object IDs.  Note  1. This parameter applies only to designs with legacy SVF derivatives generated by the BIM 360 Docs service. 2. The BIM 360 Docs service now generates SVF2 derivatives. SVF2 Object IDs may not be compatible with the SVF Object IDs previously generated by the BIM 360 Docs service. Setting this header to fallback may resolve backward compatibility issues resulting from Object IDs of legacy SVF derivatives being retained on the client side. 3. If you use this header with one derivative (URN), you must use it consistently across the following endpoints, whenever you reference the same derivative. - POST job (for OBJ output) - GET {urn}/metadata/{modelGuid} - GET {urn}/metadata/{modelGuid}/properties (optional)</param>/// <param name="forceget">true: Forcibly gets large resources even if they exceed the expected maximum size (20 MB). If the resource is larger than 800 MB, the server behaves as though forceget is false. In such a case, use the objectid query string parameter to download resources by Object ID one object at a time. Alternatively, you can use POST {urn}/metadata/{modelGuid}/properties:query to fetch only the properties you are interested in. false: (Default) Does not get resources if they exceed the expected maximum size (20 MB). (optional)</param>/// <param name="objectid">If specified, retrieves the sub-tree that has the specified object ID as its parent node. If this parameter is not specified, retrieves the entire object tree. (optional)</param>/// <param name="level">Specifies how many child levels of the hierarchy to return, when the objectid query string parameter is specified. Currently supports only level &#x3D; 1. (optional)</param>
        /// <returns>Task of ApiResponse&#60;ObjectTree&#62;</returns>
        
        public async System.Threading.Tasks.Task<ApiResponse<ObjectTree>> GetObjectTreeAsync (string urn,string modelGuid,Region region = default,string acceptEncoding= default(string),bool? xAdsForce= default(bool?),XAdsDerivativeFormat? xAdsDerivativeFormat= default(XAdsDerivativeFormat),string forceget= default(string),int? objectid= default(int?),string level= default(string), string accessToken = null, bool throwOnError = true)
        {
            logger.LogInformation("Entered into GetObjectTreeAsync ");
            string regionPath = Utils.GetPathfromRegion(region);
            using (var request = new HttpRequestMessage())
            {
                var queryParam = new Dictionary<string, object>();
                SetQueryParameter("forceget", forceget, queryParam);
                SetQueryParameter("objectid", objectid, queryParam);
                SetQueryParameter("level", level, queryParam);
                request.RequestUri =
                    Marshalling.BuildRequestUri(regionPath + "{urn}/metadata/{modelGuid}",
                        routeParameters: new Dictionary<string, object> {
                            { "urn", urn},
                            { "modelGuid", modelGuid},
                        },
                        queryParameters: queryParam
                    );

                request.Headers.TryAddWithoutValidation("Accept", "application/json");
                request.Headers.TryAddWithoutValidation("User-Agent", "APS SDK/MODEL DERIVATIVE/C#/1.0.0");
                if(!string.IsNullOrEmpty(accessToken))
                {
                    request.Headers.TryAddWithoutValidation("Authorization", $"Bearer {accessToken}");
                }



                SetHeader("Accept-Encoding", acceptEncoding, request);
                SetHeader("x-ads-force", xAdsForce, request);
                SetHeader("x-ads-derivative-format", (xAdsDerivativeFormat.ToString().ToLowerInvariant()), request);

                // tell the underlying pipeline what scope we'd like to use
                // if (scopes == null)
                // {
                    // TBD:Naren FORCE-4027 - If accessToken is null, acquire auth token using auth SDK, with defined scope.
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), "data:read ");
                // }
                // else
                // {
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), scopes);
                // }
                // if (scopes == null)
                // {
                    // TBD:Naren FORCE-4027 - If accessToken is null, acquire auth token using auth SDK, with defined scope.
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), "data:read ");
                // }
                // else
                // {
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), scopes);
                // }
                // if (scopes == null)
                // {
                    // TBD:Naren FORCE-4027 - If accessToken is null, acquire auth token using auth SDK, with defined scope.
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), "data:read ");
                // }
                // else
                // {
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), scopes);
                // }

                request.Method = new HttpMethod("GET");

                // make the HTTP request
                var response = await this.Service.Client.SendAsync(request);

                if (throwOnError)
                {
                    try
                    {
                      await response.EnsureSuccessStatusCodeAsync();
                    } catch (HttpRequestException ex) {
                      throw new ModelDerivativeApiException(ex.Message, response, ex);
                    }
                }
                else if (!response.IsSuccessStatusCode)
                {
                    logger.LogError($"response unsuccess with status code: {response.StatusCode}");
                    return new ApiResponse<ObjectTree>(response, default(ObjectTree));
                }
                logger.LogInformation($"Exited from GetObjectTreeAsync with response statusCode: {response.StatusCode}");
                return new ApiResponse<ObjectTree>(response, await LocalMarshalling.DeserializeAsync<ObjectTree>(response.Content));

            } // using
        }
        /// <summary>
        /// Fetch All Properties
        /// </summary>
        /// <remarks>
        /// Returns a list of properties of objects contained in the model view specified by the modelGuid URI parameter. This request returns all properties for all objects by default. However, you can use the objectid query string parameter to return all properties of a specified object.  Properties are returned as a flat list ordered, by their objectid. The objectid is a non-persistent ID assigned to an object when a design file is translated to the SVF or SVF2 format. This means that:  A design file must be translated to SVF or SVF2 before you can retrieve properties. The objectid of an object can change if the design is translated to SVF or SVF2 again. If you require a persistent ID to reference an object, use &#x60;externalId&#x60;.  **Note**: Before you call this endpoint:  Use the &#x60;GET {urn}/metadata&#x60; endpoint. Obtain the ID of the model view (Viewable) you want to check. Use the ID you obtained as the &#x60;modelGuid&#x60; URI parameter.  **Note**: &#x60;POST {urn}/metadata/{modelGuid}/properties:query&#x60; provides greater flexibility to retrieve only the properties you are interested in. What’s more the response is paginated. So, when the number of properties returned is large, it can getz you the results faster.
        /// </remarks>
        /// <exception cref="HttpRequestException">Thrown when fails to make API call</exception>
        /// <param name="urn">The Base64 (URL Safe) encoded design URN</param>/// <param name="modelGuid">Unique model view ID. Call GET {urn}/metadata to get the ID</param>/// <param name="acceptEncoding">A comma separated list of the algorthms you want the response to be encoded in, specified in the order of preference.    If you specify &#x60;&#x60;gzip&#x60;&#x60; or &#x60;&#x60;*&#x60;&#x60;, the service uses the GZIP algorithm to encode the response.  (optional)</param>/// <param name="xAdsForce">true: force retrieve the object tree even though it failed to be retrieved or got timeout (got 404 with error message) previously. false (default): retrieve the object tree, and previously failures are not replaced. (optional)</param>/// <param name="xAdsDerivativeFormat">Specifies what Object IDs to return, if the design has legacy SVF derivatives generated by the BIM Docs service. Possible values are:  - latest - (Default) Return SVF2 Object IDs. - fallback - Return SVF Object IDs.  Note  1. This parameter applies only to designs with legacy SVF derivatives generated by the BIM 360 Docs service. 2. The BIM 360 Docs service now generates SVF2 derivatives. SVF2 Object IDs may not be compatible with the SVF Object IDs previously generated by the BIM 360 Docs service. Setting this header to fallback may resolve backward compatibility issues resulting from Object IDs of legacy SVF derivatives being retained on the client side. 3. If you use this header with one derivative (URN), you must use it consistently across the following endpoints, whenever you reference the same derivative. - POST job (for OBJ output) - GET {urn}/metadata/{modelGuid} - GET {urn}/metadata/{modelGuid}/properties (optional)</param>/// <param name="objectid">he Object ID of the object you want to query properties for.  If objectid is omitted, the server returns properties for all objects. (optional)</param>/// <param name="forceget">true: Forcibly gets large resources even if they exceed the expected maximum size (20 MB). If the resource is larger than 800 MB, the server behaves as though forceget is false. In such a case, use the objectid query string parameter to download resources by Object ID one object at a time. Alternatively, you can use POST {urn}/metadata/{modelGuid}/properties:query to fetch only the properties you are interested in. false: (Default) Does not get resources if they exceed the expected maximum size (20 MB). (optional)</param>
        /// <returns>Task of ApiResponse&#60;AllProperties&#62;</returns>
        
        public async System.Threading.Tasks.Task<ApiResponse<AllProperties>> GetAllPropertiesAsync (string urn,string modelGuid, Region region = default,string acceptEncoding= default(string),bool? xAdsForce= default(bool?),XAdsDerivativeFormat? xAdsDerivativeFormat= default(XAdsDerivativeFormat),int? objectid= default(int?),string forceget= default(string), string accessToken = null, bool throwOnError = true)
        {
            logger.LogInformation("Entered into GetAllPropertiesAsync ");
             string regionPath = Utils.GetPathfromRegion(region);
            using (var request = new HttpRequestMessage())
            {
                var queryParam = new Dictionary<string, object>();
                SetQueryParameter("objectid", objectid, queryParam);
                SetQueryParameter("forceget", forceget, queryParam);
                request.RequestUri =
                    Marshalling.BuildRequestUri(regionPath + "{urn}/metadata/{modelGuid}/properties",
                        routeParameters: new Dictionary<string, object> {
                            { "urn", urn},
                            { "modelGuid", modelGuid},
                        },
                        queryParameters: queryParam
                    );

                request.Headers.TryAddWithoutValidation("Accept", "application/json");
                request.Headers.TryAddWithoutValidation("User-Agent", "APS SDK/MODEL DERIVATIVE/C#/1.0.0");
                if(!string.IsNullOrEmpty(accessToken))
                {
                    request.Headers.TryAddWithoutValidation("Authorization", $"Bearer {accessToken}");
                }



                SetHeader("Accept-Encoding", acceptEncoding, request);
                SetHeader("x-ads-force", xAdsForce, request);
                SetHeader("x-ads-derivative-format", (xAdsDerivativeFormat.ToString().ToLowerInvariant()), request);

                // tell the underlying pipeline what scope we'd like to use
                // if (scopes == null)
                // {
                    // TBD:Naren FORCE-4027 - If accessToken is null, acquire auth token using auth SDK, with defined scope.
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), "data:read ");
                // }
                // else
                // {
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), scopes);
                // }
                // if (scopes == null)
                // {
                    // TBD:Naren FORCE-4027 - If accessToken is null, acquire auth token using auth SDK, with defined scope.
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), "data:read ");
                // }
                // else
                // {
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), scopes);
                // }
                // if (scopes == null)
                // {
                    // TBD:Naren FORCE-4027 - If accessToken is null, acquire auth token using auth SDK, with defined scope.
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), "data:read ");
                // }
                // else
                // {
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), scopes);
                // }

                request.Method = new HttpMethod("GET");

                // make the HTTP request
                var response = await this.Service.Client.SendAsync(request);

                if (throwOnError)
                {
                    try
                    {
                      await response.EnsureSuccessStatusCodeAsync();
                    } catch (HttpRequestException ex) {
                      throw new ModelDerivativeApiException(ex.Message, response, ex);
                    }
                }
                else if (!response.IsSuccessStatusCode)
                {
                    logger.LogError($"response unsuccess with status code: {response.StatusCode}");
                    return new ApiResponse<AllProperties>(response, default(AllProperties));
                }
                logger.LogInformation($"Exited from GetAllPropertiesAsync with response statusCode: {response.StatusCode}");
                return new ApiResponse<AllProperties>(response, await LocalMarshalling.DeserializeAsync<AllProperties>(response.Content));

            } // using
        }
        /// <summary>
        /// Fetch Specific Properties
        /// </summary>
        /// <remarks>
        /// Queries the objects in the model view (Viewable) specified by the modelGuid URI parameter and returns the specified properties in a paginated list. You can limit the number of objects to be queried by specifying a filter in the request body.  Before you call this endpoint use the &#x60;GET {urn}/metadata endpoint&#x60;, to obtain the IDs of the model views (Viewables) contained in the design. After that, specify the ID of the model view you want to query as the &#x60;modelGuid&#x60; URI parameter.  **Note**: Before you query a model view for properties, the design must be translated to SVF or SVF2.
        /// </remarks>
        /// <exception cref="HttpRequestException">Thrown when fails to make API call</exception>
        /// <param name="urn">The Base64 (URL Safe) encoded design URN</param>/// <param name="modelGuid">Unique model view ID. Call GET {urn}/metadata to get the ID</param>/// <param name="acceptEncoding">A comma separated list of the algorthms you want the response to be encoded in, specified in the order of preference.    If you specify &#x60;&#x60;gzip&#x60;&#x60; or &#x60;&#x60;*&#x60;&#x60;, the service uses the GZIP algorithm to encode the response.  (optional)</param>/// <param name="specificPropertiesPayload"> (optional)</param>
        /// <returns>Task of ApiResponse&#60;SpecificProperties&#62;</returns>
        
        public async System.Threading.Tasks.Task<ApiResponse<SpecificProperties>> FetchSpecificPropertiesAsync (string urn,string modelGuid, Region region = default,string acceptEncoding= default(string),SpecificPropertiesPayload specificPropertiesPayload= default(SpecificPropertiesPayload), string accessToken = null, bool throwOnError = true)
        {
            logger.LogInformation("Entered into FetchSpecificPropertiesAsync ");
            string regionPath = Utils.GetPathfromRegion(region);
            using (var request = new HttpRequestMessage())
            {
                var queryParam = new Dictionary<string, object>();
                request.RequestUri =
                     Marshalling.BuildRequestUri(regionPath + "{urn}/metadata/{modelGuid}/properties:query",
                        routeParameters: new Dictionary<string, object> {
                            { "urn", urn},
                            { "modelGuid", modelGuid},
                        },
                        queryParameters: queryParam
                    );

                request.Headers.TryAddWithoutValidation("Accept", "application/json");
                request.Headers.TryAddWithoutValidation("User-Agent", "APS SDK/MODEL DERIVATIVE/C#/1.0.0");
                if(!string.IsNullOrEmpty(accessToken))
                {
                    request.Headers.TryAddWithoutValidation("Authorization", $"Bearer {accessToken}");
                }

                request.Content = Marshalling.Serialize(specificPropertiesPayload); // http body (model) parameter


                SetHeader("Accept-Encoding", acceptEncoding, request);

                // tell the underlying pipeline what scope we'd like to use
                // if (scopes == null)
                // {
                    // TBD:Naren FORCE-4027 - If accessToken is null, acquire auth token using auth SDK, with defined scope.
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), "data:read ");
                // }
                // else
                // {
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), scopes);
                // }
                // if (scopes == null)
                // {
                    // TBD:Naren FORCE-4027 - If accessToken is null, acquire auth token using auth SDK, with defined scope.
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), "data:read ");
                // }
                // else
                // {
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), scopes);
                // }
                // if (scopes == null)
                // {
                    // TBD:Naren FORCE-4027 - If accessToken is null, acquire auth token using auth SDK, with defined scope.
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), "data:read ");
                // }
                // else
                // {
                    // request.Properties.Add(ForgeApsConfiguration.ScopeKey.ToString(), scopes);
                // }

                request.Method = new HttpMethod("POST");

                // make the HTTP request
                var response = await this.Service.Client.SendAsync(request);

                if (throwOnError)
                {
                    try
                    {
                      await response.EnsureSuccessStatusCodeAsync();
                    } catch (HttpRequestException ex) {
                      throw new ModelDerivativeApiException(ex.Message, response, ex);
                    }
                }
                else if (!response.IsSuccessStatusCode)
                {
                    logger.LogError($"response unsuccess with status code: {response.StatusCode}");
                    return new ApiResponse<SpecificProperties>(response, default(SpecificProperties));
                }
                logger.LogInformation($"Exited from FetchSpecificPropertiesAsync with response statusCode: {response.StatusCode}");
                return new ApiResponse<SpecificProperties>(response, await LocalMarshalling.DeserializeAsync<SpecificProperties>(response.Content));

            } // using
        }
    }
}
